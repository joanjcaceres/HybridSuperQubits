import os
import re
from scipy.integrate import nquad
import scipy.constants as const
import numpy as np
import matplotlib.pyplot as plt

def calculate_mutual(loop_size:list[float],offset_position:list[float], flux_line_length:float, flux_line_width:float) -> float:
    """
    Calculates the mutual inductance between a rectangular loop and a triangular flux line.

    The calculation assumes units are in micrometers to avoid rounding errors. Currently, the function is 
    only valid for rectangular loops and assumes a triangular shape of the flux line, with the apex of the 
    triangle located at the origin (0,0) of the coordinate system.

    Parameters:
    - loop_size: A list of two floats representing the size of the rectangle in micrometers. The format is [width, height].
    - offset_position: A list of two floats indicating the coordinates (in micrometers) of the rectangle's corner 
      closest to the origin (0,0). The format is [x_offset, y_offset].
    - flux_line_length: The length of one side of the triangular flux line along the y-axis, in micrometers.
    - flux_line_width: The width of the base of the triangular flux line, in micrometers.

    Returns:
    - The calculated mutual inductance in Henrys.

    Note:
    - The function is currently only implemented for rectangular loops and triangular flux lines.
    - Future improvements might include support for arbitrary shapes defined by a set of points.

    The mutual inductance is calculated by integrating over the specified rectangle and flux line dimensions,
    considering the magnetic field generated by the triangular flux line. The center point of the flux line 
    is considered to be at (0,0).
    """
    
    integrand = lambda x,y,l,w : (x-w) / np.sqrt((x-w)**2 + (y - l)**2)**3 - (x-w) / np.sqrt((x-w)**2 + (y + l)**2)**3

    ranges =[
        [offset_position[0], offset_position[0]+ loop_size[0]],
        [offset_position[1], offset_position[1]+ loop_size[1]],
        [0,flux_line_length],
        [-flux_line_width/2,flux_line_width/2]
    ]

    result = nquad(integrand, ranges)

    return const.mu_0/4/np.pi/2 * result[0]/flux_line_width * 1e-6

def load_data(base_name):
    """
    Load data from a base name.

    Parameters:
    base_name (str): Base name of the files and directory.

    Returns:
    dict: Dictionary containing all data columns.
    """
    # Define paths to the files and directories based on the base name
    x_file = f'{base_name}.txt'
    y_directory = f'{base_name}-children'

    # Initialize the dictionary
    data_dict = {}

    # Load X-axis data
    with open(x_file, 'r') as file:
        lines = file.readlines()

    # Extract parameters from the header
    parameters = read_parameters(lines)
    if parameters:
        data_dict['parameters'] = parameters

    # Find the end of the header and read column headers
    header_end_idx = 0
    for i, line in enumerate(lines):
        if line.strip() == '#end of header':
            header_end_idx = i
            break

    # Read the column headers
    column_headers = lines[header_end_idx + 1].strip().split()

    # Read the data after the header
    data = [line.strip().split() for line in lines[header_end_idx + 2:] if line.strip()]
    data = np.array(data, dtype=float)

    num_rows = data.shape[0]

    # Populate the data dictionary with columns from x_file
    for i, header in enumerate(column_headers):
        data_dict[header] = data[:, i]

    # Check if the directory exists
    if os.path.isdir(y_directory):
        filenames = sorted([f for f in os.listdir(y_directory) if f.endswith('.txt')])

        mask = []

        for idx, filename in enumerate(filenames):
            if idx >= num_rows:
                break
            y_file = os.path.join(y_directory, filename)
            with open(y_file, 'r') as file:
                lines = file.readlines()

            # Find the end of the header
            header_end_idx = 0
            for i, line in enumerate(lines):
                if line.strip() == '#end of header':
                    header_end_idx = i
                    break

            # Read the column headers
            file_column_headers = lines[header_end_idx + 1].strip().split()

            # Read the data after the header
            data = [line.strip().split() for line in lines[header_end_idx + 2:] if line.strip()]
            data = np.array(data, dtype=float)
            if idx == 0:
                correct_shape = data.shape
            if not data.shape == correct_shape:
                mask.append(idx)

            # Populate the data dictionary with columns from y_directory
            for i, header in enumerate(file_column_headers):
                if header not in data_dict:
                    data_dict[header] = []
                if data.shape == correct_shape:
                    data_dict[header].append(data[:, i])

        for key in data_dict:
            if isinstance(data_dict[key], list):
                data_dict[key] = np.array(data_dict[key])

    for i, header in enumerate(column_headers):
        if isinstance(data_dict[header], np.ndarray):
            data_dict[header] = np.delete(data_dict[header], mask, axis=0)

    return data_dict

import h5py

def load_data_and_metadata(file_path):
    datasets = {}
    metadata = {}

    def load_group(group, path=''):
        # Load attributes as metadata
        for attr in group.attrs:
            metadata_key = f"{path}/{attr}" if path else attr
            metadata[metadata_key] = group.attrs[attr]

        # Load datasets or dive into subgroups
        for name in group:
            item_path = f"{path}/{name}" if path else name
            if isinstance(group[name], h5py.Dataset):
                datasets[item_path] = group[name][...]
            elif isinstance(group[name], h5py.Group):
                load_group(group[name], item_path)

    with h5py.File(file_path, 'r') as file:
        load_group(file)

    return datasets, metadata


def plot_phase_map(data_dict, x_key, y_key, z_key, title='Phase Map', correct_horizontal=False, correct_vertical=False, fig=None, ax=None, **kwargs):
    """
    Plot a 2D phase map using the provided X-axis values, Y-axis values, and Z-axis matrix.

    Parameters:
    data_dict (tuples): Tuples containing (x_values, y_values, Z_values).
    x_key (str): Key for the x_values to plot.
    y_key (str): Key for the y_values to plot.
    z_key (str): Key for the z_values to plot.
    title (str): Title of the plot.
    correct_horizontal (bool): Whether to apply horizontal correction.
    correct_vertical (bool): Whether to apply vertical correction.
    fig (matplotlib.figure.Figure, optional): Figure object to use for plotting.
    ax (matplotlib.axes.Axes, optional): Axes object to use for plotting.
    kwargs: Additional keyword arguments to pass to pcolormesh.
    """
    if fig is None or ax is None:
        figsize= kwargs.pop('figsize', (8, 6))
        fig, ax = plt.subplots(figsize=figsize)  # Create a new figure and axis if not provided
    
    x_data = data_dict[x_key]
    y_data = data_dict[y_key]
    z_data = data_dict[z_key]

    # Apply corrections if specified
    if x_data.ndim == 1:
        Y = y_data
        X = np.tile(x_data, (Y.shape[1], 1)).T
        if correct_horizontal:
            z_data = average_and_subtract_horizontal(z_data)
        if correct_vertical:
            z_data = average_and_subtract_vertical(z_data)
    elif y_data.ndim == 1: # In case it's inverted the axis.
        X = x_data
        Y = np.tile(y_data, (X.shape[1], 1)).T
        if correct_vertical:
            z_data = average_and_subtract_horizontal(z_data)
        if correct_horizontal:
            z_data = average_and_subtract_vertical(z_data)

    # Plot using pcolormesh
    vmin = kwargs.pop('vmin', None)
    vmax = kwargs.pop('vmax', None)
    mesh = ax.pcolormesh(X, Y, z_data, shading='auto', vmin=vmin, vmax=vmax,**kwargs)
    
    ax.set_title(title)
    ax.set_xlabel(x_key)
    ax.set_ylabel(y_key)
    fig.tight_layout()
    
    return fig, ax, mesh
    
def plot_multiple_phase_maps_in_one_ax(data_dicts, x_key, y_key, z_key, title='Superimposed Phase Maps', correct_horizontal=False, correct_vertical=False, **kwargs):
    figsize = kwargs.pop('figsize', (8, 6))
    fig, ax = plt.subplots(figsize=figsize)
    
    vmin = kwargs.pop('vmin', None)
    vmax = kwargs.pop('vmax', None)
    
    # Check that all data_dicts have the required keys and z_key contains arrays
    for key, data_dict in data_dicts.items():
        if z_key not in data_dict or not isinstance(data_dict[z_key], np.ndarray):
            raise ValueError(f"Each data_dict must contain the key '{z_key}' with a numpy array as its value.")
    
    if vmin is None or vmax is None:
        z_data_combined = np.concatenate([data_dict[z_key].flatten() for key, data_dict in data_dicts.items()])
        vmin = vmin if vmin is not None else np.min(z_data_combined)
        vmax = vmax if vmax is not None else np.max(z_data_combined)
    
    for key, data_dict in data_dicts.items():
        fig, ax, mesh = plot_phase_map(data_dict, x_key, y_key, z_key, title='', correct_horizontal=correct_horizontal, correct_vertical=correct_vertical, fig=fig, ax=ax, vmin=vmin, vmax=vmax, **kwargs)
    
    cbar = fig.colorbar(mesh, ax=ax, orientation='vertical', fraction=0.02, pad=0.04)
    cbar.ax.set_ylabel('Intensity')
    ax.set_title(title)
    plt.tight_layout()
    plt.show()

def average_and_subtract_vertical(phase_matrix):
    """
    Calculate the vertical average and subtract it from each row in the phase matrix.

    Parameters:
    phase_matrix (np.ndarray): Matrix of phase values.

    Returns:
    np.ndarray: Phase matrix with vertical averages subtracted.
    """
    vertical_mean = np.nanmean(phase_matrix, axis=1)  # Calculate mean of each row
    phase_matrix_corrected = phase_matrix - vertical_mean[:, np.newaxis]  # Subtract the mean from each row
    return phase_matrix_corrected

def average_and_subtract_horizontal(phase_matrix):
    """
    Calculate the horizontal average and subtract it from each column in the phase matrix.

    Parameters:
    phase_matrix (np.ndarray): Matrix of phase values.

    Returns:
    np.ndarray: Phase matrix with horizontal averages subtracted.
    """
    horizontal_mean = np.nanmean(phase_matrix, axis=0)  # Calculate mean of each column
    phase_matrix_corrected = phase_matrix - horizontal_mean  # Subtract the mean from each column
    return phase_matrix_corrected

def plot_1d_line(datasets, x_key, y_key, z_key, fixed_x=None, fixed_y=None, tolerance=0.01, apply_vertical_correction=False, apply_horizontal_correction=False, 
                 fig=None, ax=None, **kwargs):
    """
    Plot a 1D line at a fixed Y value on an existing phase map.

    Parameters:
    datasets (list of dict): List of dictionaries containing all data columns.
    fixed_y (float): Fixed Y value to plot a 1D line.
    x_key (str): Key for the x_values to plot.
    y_key (str): Key for the y_values to plot.
    z_key (str): Key for the z_values to plot.
    tolerance (float): Tolerance within which the nearest Y value must be to fixed_y.
    apply_vertical_correction (bool): Whether to apply vertical correction to the z_values.
    apply_horizontal_correction (bool): Whether to apply horizontal correction to the z_values.
    fig (matplotlib.figure.Figure, optional): Figure object to use for plotting.
    ax (matplotlib.axes.Axes, optional): Axes object to use for plotting.
    kwargs: Additional keyword arguments to pass to the plot function.
    """
    if fig is None or ax is None:
        figsize =kwargs.pop('figsize', (8,6))
        fig, ax = plt.subplots(figsize=figsize)  # Create a new figure and axis if not provided
    
    if fixed_x is not None and fixed_y is not None:
        raise ValueError("Both fixed_x and fixed_y shouldn't be different to None.")
    
    x_data = datasets[x_key]
    y_data = datasets[y_key]
    z_data = datasets[z_key]

    if x_data.ndim == 1:
        Y = y_data
        X = np.tile(x_data, (Y.shape[1], 1)).T
        if apply_horizontal_correction:
            z_data = average_and_subtract_horizontal(z_data)
        if apply_vertical_correction:
            z_data = average_and_subtract_vertical(z_data)
    elif y_data.ndim == 1: # In case it's inverted the axis.
        X = x_data
        Y = np.tile(y_data, (X.shape[1], 1)).T
        if apply_vertical_correction:
            z_data = average_and_subtract_horizontal(z_data)
        if apply_horizontal_correction:
            z_data = average_and_subtract_vertical(z_data)

    #This only works when x_data is 1D array.

    if fixed_y is not None:
        y_index = (np.abs(Y[:,0] - fixed_y)).argmin()
        z_1d = z_data[y_index,:]

        y_nearest = Y[y_index,0]
        if np.abs(y_nearest - fixed_y) > tolerance:
            print(f"Skipping dataset with y_nearest = {y_nearest:.2f} (outside tolerance of {tolerance})")


        ax.plot(x_data[0,:], z_1d, label=f'Y = {y_nearest:.2f}', **kwargs)
        ax.set_xlabel(x_key)
        ax.set_ylabel(z_key)
    elif fixed_x is not None:
        x_index = (np.abs(X - fixed_x)).argmin()
        z_1d = z_data[x_index, :]

        x_nearest = X[x_index]
        if np.abs(x_nearest - fixed_x) > tolerance:
            print(f"Skipping dataset with x_nearest = {x_nearest:.2f} (outside tolerance of {tolerance})")

        ax.plot(z_1d,y_data[0,:], label=f'X = {x_nearest:.2f}', **kwargs)
    ax.set_xlabel(z_key)
    ax.set_ylabel(y_key)

    ax.legend()
    fig.tight_layout()
    return fig, ax

def read_parameters(lines):
    in_parameters_section = False
    parameters = {}

    for line in lines:
        stripped_line = line.strip()
        
        # Start reading parameters after the line containing 'parameters:'
        if stripped_line == 'parameters:':
            in_parameters_section = True
            continue
        
        # Stop reading if '#end of header' is reached
        if stripped_line == '#end of header':
            break

        # Process only lines within the 'parameters' section that are indented
        if in_parameters_section and line.startswith('  '):  # Assuming parameters are indented with two spaces
            if ':' in line:
                key_value_pair = line.strip().split(': ', 1)
                if len(key_value_pair) == 2:
                    key, value = key_value_pair
                    # Remove potential trailing commas and spaces
                    value = value.rstrip(', ')
                    # Try to handle values that are numerical or lists
                    try:
                        if '[' in value and ']' in value:  # Handles list values
                            value = eval(value)  # Safely evaluate the string to a Python list
                        else:
                            value = float(value)
                    except ValueError:
                        pass  # Keep the value as is if it's not a number or list
                    
                    parameters[key] = value

    return parameters if parameters else None

def last_measurement(directory):
    max_number = None
    # Regex to match the file pattern
    file_pattern = re.compile(r'FBW10S4_(\d+)\.txt')

    for filename in os.listdir(directory):
        # Check if the filename matches the pattern
        match = file_pattern.match(filename)
        if match:
            number = int(match.group(1))
            corresponding_folder = f"FBW10S4_{number}-children"

            # Check if the corresponding folder exists
            if os.path.isdir(os.path.join(directory, corresponding_folder)):
                if max_number is None or number > max_number:
                    max_number = number

    return max_number


